// console.log(typeof nuri);
// console.log(typeof text);



// let nuri = "El Mundo";
// let text = "like a ";
// // let sushi = "sushi";
// // let snack = "snack";


// let foodObject = {  // 객체가 생겨난 이유 -> 규칙이 없으나 얼마나 잘 묶는지가 관건!
//   sushi:"shusi",
//   snack:"snack",
//   coffe:"coffe"
// }

// 알고리즘, 프로그래밍 하기 따라 객체, 배열, 변수는 얼마든지 바꾸며 사용 가능

// * 자료구조 
// * 변수를 작명 할 때 "데이터타입"을 표시해 주는 버릇을 가지면 찾을 필요가 없음 
// * "nuri 변수는 foodObject라는 객체의 무언가는 가져다 쓸 것이다" 라고 예상 가능
// -> 값이 별로 중요하지 않음 = 타입이 중요!



// let stringSum = nuri + text + sushi;
// 변수 stringSum은 변수 nuri와 변수 text를 앞뒤로 합친 것을 stringSum 변수에 대입

// let stringSum = `${nuri} ${text} ${foodObject.coffe}`

// console.log(stringSum);

// console.log(food);




// let pokemon = ["이상해씨", "이상해풀", "이상해꽃", "파이리", "리자드", "리자몽"]
// // 배열에는 원소(요소 - element), lenth 값이 6인 데이터를 변수 pokemon에 대입.

// console.log(pokemon);
// console.log(pokemon.length);
// // 배열의 키값(객체) 중 길이 값을 가져오는 length라는 프로퍼티를 접근 (getter성격)

// console.log(pokemon[3]);
// console.log(pokemon[pokemon.length-1]);
// //  길이값의 -1 - 무조건 마지막 원소


// let three = 3;

// console.log(pokemon[three]);



// let max = `${pokemon[0]} 포켓몬의 최종진화는 ${pokemon[0+2]}`;
// console.log(max)


let coffeeObject = ["아메리카노", "카페라떼", "카푸치노", "망고패션후르츠프라페치노", "카라멜프라페치노", "화이트카페모카"];

let europeArray = ["UK", "SPAIN", "ITALY", "FRANCE", "GERMANY", "CZECH", "BELGIUM"];






